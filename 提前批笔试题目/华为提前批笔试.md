# 时间2021/6/30

1. <img src="image/image-20210701191721239.png" alt="image-20210701191721239" style="zoom: 50%;" />

   > 参考leetcode135题 hard，贪心思想

   输入：第一行为为员工数量N(1\<=N\<=1000),第二行为每位员工的考核评分

   输出：最少需要发出的礼品份数

   测试样例：3 / 1 0 2 =>6     5 / 9 45 86 51 3 =>12

   **思路：**

   	* 注意与原题的不同，这里是环形数组的表达，数组首位和末尾是相邻的
    *  原题贪心思想借用一下
         	* 先找到数组中最小的数（评分最低），过程中给每个员工都发一份奖品
         
      	* 从最小数的位置i开始，往右遍历，下一位比本位评分高，就给下一位+1（多发一份奖品），一直到回到i
      	
      	* 从最小数的位置i开始，往左遍历，下一位比本位评分高，就给下一位+1（多发一份奖品），一直到回到i。输出最终结果

   **代码：**

   ~~~C++
   
   
   
   ~~~

   

2. <img src="image/image-20210701192733281.png" alt="image-20210701192733281" style="zoom:67%;" />

   ​	

   > 无参考

   输出要求：第一行输出子序列长度，第二、三行给出子序列(<font color=red>注意要给出两个子序列</font>)

   测试样例：1 2 3 4 5 \n 2 4 6 8 =>3 \n 1 3 5 \n 2 4 6     1 2 3 4 5 \n 2 7 12 17 => 0

   **思路：**

    * 感觉数据范围是DP，但是想不出来，可能思考错误了

   **代码：**

   ~~~C++
   
   
   ~~~

   

3. <img src="image/image-20210701193415167.png" alt="image-20210701193415167" style="zoom: 67%;" />

   <img src="image/image-20210701193431437.png" alt="image-20210701193431437" style="zoom:67%;" />

   <img src="image/image-20210701193448198.png" alt="image-20210701193448198" style="zoom:67%;" />

   > 参考经典BFS，增加一些状态更新的处理即可

   输出要求：第一行输出子序列长度，第二、三行给出子序列(<font color=red>注意要给出两个子序列</font>)

   测试样例：1 2 3 4 5 \n 2 4 6 8 =>3 \n 1 3 5 \n 2 4 6     1 2 3 4 5 \n 2 7 12 17 => 0

   **思路：**

    * BFS，不走回头路，并且判断下一步是不是死地

   **代码：**

   ~~~C++
   #include <iostream>
   #include <vector>
   #include <queue>
   #include <algorithm>
   using namespace std;
   
   int row, col;
   
   int dx[4] = {0,1,0,-1};
   int dy[4] = {1,0,-1,0};
   
   int main(){
       cin>>row>>col;
       if(row==1 && col==1){
           cout<<0;
           return 0;
       }
       vector<vector<int>> map(row, vector<int>(col, 0));
       vector<vector<int>> visited(row, vector<int>(col, 0));
       for(int i=0; i<row; i++){
           for(int j=0; j<col; j++){
               cin>>map[i][j];
           }
       }
       queue<pair<int, int>> q;
       q.push({0,0});
       visited[0][0] = 1;
       int cnt = 1;
       while(!q.empty()){
           int size = q.size();
           for(int t=0; t<size; t++){
               auto cur = q.front();
               q.pop();
               for(int i=0; i<4; i++){
                   int x = cur.first + dx[i];
                   int y = cur.second + dy[i];
                   if(x<0 || x>=row || y<0 || y>=col) continue;
                   if(x==row-1 && y==col-1){
                       cout<<cnt;
                       return 0 ;
                   }
                   if(map[x][y]-cnt >=0 && visited[x][y]==0){
                       map[x][y] -= cnt;
                       visited[x][y] = 1;
                       q.push({x,y});
                   }
               }
           }
           cnt++;
       }
       cout<<-1;
       return 0;
   }
   ~~~

