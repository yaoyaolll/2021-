# shopee一面（后端开发）

## 问题

1. 进程和线程的区别
2. 什么时候用进程，什么时候用线程
3. 进程和线程各自的通信方式
4. TCP和UDP的区别
5. 详细讲讲TCP如何保证可靠传输
6. TCP的分包和黏包
7. B树和B+树的区别
8. B+树有哪些应用场景
9. Go语言的GPM模型
10. Go语言的GC模型
11. 问我会不会什么数据库，答：只会SQL语言，不太会数据库

## 算法题

算法题比较简单，没有记

另附华为提前批两道面试题：

1. 下一个更大元素(LC-503)

   给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

   示例1：

   ~~~
   输入: [1,2,1]
   输出: [2,-1,2]
   解释: 第一个 1 的下一个更大的数是 2；
   数字 2 找不到下一个更大的数； 
   第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
   ~~~

   代码：

   ~~~C++
   vector<int> nextGreaterElements(vector<int>& nums) {
       stack<int> s;// 单调栈，栈中存的是数组下标，但是比较时候是提取下标元素
       int len = nums.size();
       vector<int> res(len, -1);// 初始都是-1（未找到状态）
       for(int i=0; i<2*len; i++){
           int num = nums[i%len];
           while(!s.empty() && num > nums[s.top()]){
               res[s.top()] = num;
               s.pop();
           }
           if(i<len) s.push(i);
       }
       return res;
   }
   ~~~

2. 圆圈中最后剩下的数字(LC-剑指Offer62 约瑟夫环问题)

   0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

   例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

   示例：

   ~~~
   输入: n = 5, m = 3
   输出: 3
   输入: n = 10, m = 17
   输出: 2
   ~~~

   代码：

   ~~~C++
   int lastRemaining(int n, int m) {
       // 约瑟夫环
       int f = 0;
       for(int i=2; i<n+1; i++){
           f = (m+f) % i;
       }
       // 动态规划解决
       return f;
   }
   ~~~

   

